<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ¬</text></svg>">
    <title>Veo Watermark Remover</title>
    <!-- MP4 Muxer for creating MP4 files -->
    <script src="https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/build/mp4-muxer.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        * { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --primary: #8b5cf6;
            --primary-dark: #7c3aed;
            --accent: #06b6d4;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --dark: #0f0f1a;
            --dark-light: #1a1a2e;
            --gray: #6b7280;
            --gray-light: #9ca3af;
            --light: #f3f4f6;
            --white: #ffffff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--dark) 0%, #1a1a2e 100%);
            min-height: 100vh;
            color: var(--light);
        }

        .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #fff, #a5b4fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle { text-align: center; color: var(--gray-light); margin-bottom: 32px; }

        .card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .drop-zone {
            border: 2px dashed rgba(139,92,246,0.3);
            border-radius: 16px;
            padding: 50px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 24px;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(139,92,246,0.05);
        }

        .drop-zone h2 { font-size: 1.3em; margin-bottom: 8px; }
        .drop-zone p { color: var(--gray); }

        .btn-row { display: flex; gap: 12px; justify-content: center; margin-bottom: 24px; flex-wrap: wrap; }

        .btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 12px 24px;
            border-radius: 10px;
            color: var(--light);
            cursor: pointer;
            font-family: inherit;
            font-size: 0.95em;
            transition: all 0.2s;
        }

        .btn:hover { background: rgba(139,92,246,0.15); border-color: var(--primary); }

        input[type="file"] { display: none; }

        .progress-section { display: none; }
        .progress-section.active { display: block; }

        .progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 12px 0;
        }

        .progress-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.2s;
        }

        .progress-info { display: flex; justify-content: space-between; font-size: 0.85em; color: var(--gray); }

        .video-list { display: flex; flex-direction: column; gap: 12px; }

        .video-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .video-item video {
            width: 100px; height: 56px;
            object-fit: cover;
            border-radius: 6px;
            background: #000;
        }

        .video-item .info { flex: 1; }
        .video-item .name { font-weight: 500; margin-bottom: 4px; font-size: 0.95em; }
        .video-item .status { font-size: 0.85em; color: var(--gray); }
        .video-item .status.processing { color: var(--warning); }
        .video-item .status.done { color: var(--success); }
        .video-item .status.error { color: var(--error); }

        .video-item .download {
            background: var(--success);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            display: none;
        }

        .video-item.done .download { display: block; }

        .back-link { color: var(--gray); text-decoration: none; display: inline-block; margin-bottom: 20px; }
        .back-link:hover { color: var(--light); }

        .error-box {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
            display: none;
        }
        .error-box.show { display: block; }
        .error-box h4 { color: var(--error); margin-bottom: 8px; }
        .error-box p { color: var(--gray-light); font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">â† ×—×–×¨×” ×œ×ª××•× ×•×ª</a>

        <h1>Veo Watermark Remover</h1>
        <p class="subtitle">×”×¡×¨×ª ×¡×™××Ÿ ×”××™× "Veo" ××¡×¨×˜×•× ×™ Google Veo - ×¤×œ×˜ MP4</p>

        <div class="error-box" id="errorBox">
            <h4>×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š</h4>
            <p>× ×“×¨×© Chrome 94+ ××• Edge 94+ ×¢× ×ª××™×›×” ×‘-WebCodecs API ×œ×™×¦×™×¨×ª MP4.</p>
        </div>

        <div class="drop-zone" id="dropZone">
            <h2>×’×¨×•×¨ ×¡×¨×˜×•× ×™× ×œ×›××Ÿ</h2>
            <p>××• ×œ×—×¥ ×œ×‘×—×™×¨×ª ×§×‘×¦×™× â€¢ MP4, WebM, MOV</p>
        </div>

        <div class="btn-row">
            <label class="btn">
                ×‘×—×¨ ×¡×¨×˜×•×Ÿ
                <input type="file" id="fileInput" accept="video/*">
            </label>
            <label class="btn">
                ×‘×—×¨ ×ª×™×§×™×™×”
                <input type="file" id="folderInput" webkitdirectory multiple accept="video/*">
            </label>
        </div>

        <div class="card progress-section" id="progressSection">
            <div class="progress-info">
                <span id="progressText">××¢×‘×“...</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="fill" id="progressFill"></div>
            </div>
            <div class="progress-info">
                <span id="currentFile">-</span>
                <span id="eta">-</span>
            </div>
        </div>

        <div class="video-list" id="videoList"></div>
    </div>

    <script>
        // Check browser support
        if (typeof VideoEncoder === 'undefined' || typeof Mp4Muxer === 'undefined') {
            document.getElementById('errorBox').classList.add('show');
        }

        // ============== CONFIG ==============
        const CONFIG = {
            // Base resolution where bg.png was captured
            baseWidth: 1280,
            baseHeight: 720,
            // Mask image dimensions
            maskWidth: 60,
            maskHeight: 30,
            // Margins at base resolution
            marginRight: 10,
            marginBottom: 10,
            // Alpha settings
            opacity: 0.52
        };

        // ============== LOAD MASK IMAGE ==============
        let baseMask = null;
        let baseMaskData = null;

        async function loadMaskImage() {
            if (baseMask) return baseMask;

            const img = new Image();
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = () => reject(new Error('Failed to load bg.png'));
                img.src = 'bg.png';
            });

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;
            const mask = new Float32Array(img.width * img.height);

            for (let i = 0; i < mask.length; i++) {
                const idx = i * 4;
                const maxChannel = Math.max(data[idx], data[idx + 1], data[idx + 2]);
                mask[i] = maxChannel / 255.0;
            }

            baseMask = { mask, w: img.width, h: img.height };
            console.log(`Loaded Veo mask ${img.width}x${img.height}`);
            return baseMask;
        }

        // Load mask on startup
        loadMaskImage().catch(err => {
            console.error('Failed to load mask:', err);
            alert('×©×’×™××”: ×œ× × ×™×ª×Ÿ ×œ×˜×¢×•×Ÿ ××ª bg.png');
        });

        // ============== SCALE MASK FOR VIDEO ==============
        function createScaledMask(videoWidth, videoHeight) {
            if (!baseMask) throw new Error('Mask not loaded');

            // Calculate scale based on video height relative to base
            const scale = videoHeight / CONFIG.baseHeight;

            const scaledW = Math.round(CONFIG.maskWidth * scale);
            const scaledH = Math.round(CONFIG.maskHeight * scale);
            const marginRight = Math.round(CONFIG.marginRight * scale);
            const marginBottom = Math.round(CONFIG.marginBottom * scale);

            // Create scaled mask using bilinear interpolation
            const scaledMask = new Float32Array(scaledW * scaledH);

            for (let y = 0; y < scaledH; y++) {
                for (let x = 0; x < scaledW; x++) {
                    // Map to original coordinates
                    const srcX = (x / scaledW) * baseMask.w;
                    const srcY = (y / scaledH) * baseMask.h;

                    const x0 = Math.floor(srcX);
                    const y0 = Math.floor(srcY);
                    const x1 = Math.min(x0 + 1, baseMask.w - 1);
                    const y1 = Math.min(y0 + 1, baseMask.h - 1);

                    const dx = srcX - x0;
                    const dy = srcY - y0;

                    const v00 = baseMask.mask[y0 * baseMask.w + x0];
                    const v10 = baseMask.mask[y0 * baseMask.w + x1];
                    const v01 = baseMask.mask[y1 * baseMask.w + x0];
                    const v11 = baseMask.mask[y1 * baseMask.w + x1];

                    const value = v00 * (1-dx) * (1-dy) + v10 * dx * (1-dy) +
                                  v01 * (1-dx) * dy + v11 * dx * dy;

                    scaledMask[y * scaledW + x] = value * CONFIG.opacity;
                }
            }

            return {
                mask: scaledMask,
                w: scaledW,
                h: scaledH,
                x: videoWidth - scaledW - marginRight,
                y: videoHeight - scaledH - marginBottom
            };
        }

        const ALPHA_THRESHOLD = 0.002;
        const MAX_ALPHA = 0.99;
        const LOGO_VALUE = 255; // White watermark

        function removeWatermark(imageData, mask) {
            const d = imageData.data;
            const imgW = imageData.width;

            for (let y = 0; y < mask.h; y++) {
                for (let x = 0; x < mask.w; x++) {
                    const imgX = mask.x + x;
                    const imgY = mask.y + y;
                    if (imgX < 0 || imgX >= imgW || imgY < 0 || imgY >= imageData.height) continue;

                    const idx = (imgY * imgW + imgX) * 4;
                    let alpha = mask.mask[y * mask.w + x];

                    if (alpha < ALPHA_THRESHOLD) continue;
                    alpha = Math.min(alpha, MAX_ALPHA);

                    const divisor = 1 - alpha;

                    d[idx]   = Math.max(0, Math.min(255, Math.round((d[idx]   - alpha * LOGO_VALUE) / divisor)));
                    d[idx+1] = Math.max(0, Math.min(255, Math.round((d[idx+1] - alpha * LOGO_VALUE) / divisor)));
                    d[idx+2] = Math.max(0, Math.min(255, Math.round((d[idx+2] - alpha * LOGO_VALUE) / divisor)));
                }
            }
        }

        // ============== VIDEO PROCESSING ==============
        const queue = [];
        let processing = false;

        function updateProgress(pct, text, file, eta) {
            document.getElementById('progressFill').style.width = pct + '%';
            document.getElementById('progressPercent').textContent = Math.round(pct) + '%';
            if (text) document.getElementById('progressText').textContent = text;
            if (file) document.getElementById('currentFile').textContent = file;
            if (eta !== undefined) document.getElementById('eta').textContent = eta;
        }

        async function processVideo(file, itemEl) {
            const statusEl = itemEl.querySelector('.status');

            if (typeof VideoEncoder === 'undefined') {
                throw new Error('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘-WebCodecs');
            }

            // Ensure mask is loaded
            await loadMaskImage();

            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;

            await new Promise((res, rej) => { video.onloadedmetadata = res; video.onerror = rej; });

            const W = video.videoWidth;
            const H = video.videoHeight;
            const duration = video.duration;
            const fps = 30;
            const totalFrames = Math.ceil(duration * fps);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = W;
            canvas.height = H;

            const mask = createScaledMask(W, H);
            const startTime = Date.now();

            statusEl.textContent = '××›×™×Ÿ MP4...';

            // Create MP4 muxer
            const muxer = new Mp4Muxer.Muxer({
                target: new Mp4Muxer.ArrayBufferTarget(),
                video: {
                    codec: 'avc',
                    width: W,
                    height: H
                },
                fastStart: 'in-memory'
            });

            // Create video encoder
            const encoder = new VideoEncoder({
                output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
                error: e => console.error('Encoder error:', e)
            });

            encoder.configure({
                codec: 'avc1.640028',
                width: W,
                height: H,
                bitrate: 8_000_000,
                framerate: fps
            });

            statusEl.textContent = `××¢×‘×“ ${totalFrames} ×¤×¨×™×™××™×...`;

            // Process frames
            for (let i = 0; i < totalFrames; i++) {
                video.currentTime = i / fps;
                await new Promise(r => video.onseeked = r);

                ctx.drawImage(video, 0, 0);
                const imgData = ctx.getImageData(0, 0, W, H);
                removeWatermark(imgData, mask);
                ctx.putImageData(imgData, 0, 0);

                const frame = new VideoFrame(canvas, {
                    timestamp: (i / fps) * 1_000_000,
                    duration: (1 / fps) * 1_000_000
                });

                encoder.encode(frame, { keyFrame: i % 60 === 0 });
                frame.close();

                const pct = (i / totalFrames) * 95;
                const elapsed = (Date.now() - startTime) / 1000;
                const rate = (i + 1) / elapsed;
                const remaining = Math.round((totalFrames - i - 1) / rate);

                updateProgress(pct, `×¤×¨×™×™× ${i + 1}/${totalFrames}`, file.name, `× ×•×ª×¨: ${remaining}s`);

                if (i % 3 === 0) await new Promise(r => setTimeout(r, 0));
            }

            await encoder.flush();
            encoder.close();
            muxer.finalize();

            updateProgress(100, '×™×•×¦×¨ MP4...', file.name, '');
            statusEl.textContent = '×™×•×¦×¨ MP4...';

            const { buffer } = muxer.target;
            const blob = new Blob([buffer], { type: 'video/mp4' });

            URL.revokeObjectURL(video.src);
            return blob;
        }

        async function processQueue() {
            if (processing || queue.length === 0) return;
            processing = true;

            document.getElementById('progressSection').classList.add('active');

            while (queue.length > 0) {
                const { file, itemEl } = queue.shift();
                const statusEl = itemEl.querySelector('.status');
                statusEl.className = 'status processing';

                try {
                    const blob = await processVideo(file, itemEl);

                    const url = URL.createObjectURL(blob);
                    const dlBtn = itemEl.querySelector('.download');
                    dlBtn.onclick = () => {
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = file.name.replace(/\.[^.]+$/, '') + '-clean.mp4';
                        a.click();
                    };

                    dlBtn.click();

                    statusEl.textContent = '×”×•×©×œ×! (' + (blob.size / 1024 / 1024).toFixed(1) + ' MB)';
                    statusEl.className = 'status done';
                    itemEl.classList.add('done');

                } catch (err) {
                    console.error(err);
                    statusEl.textContent = '×©×’×™××”: ' + err.message;
                    statusEl.className = 'status error';
                }
            }

            processing = false;
            document.getElementById('progressSection').classList.remove('active');
        }

        function addVideos(files) {
            if (typeof VideoEncoder === 'undefined') {
                alert('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘-WebCodecs. × ×“×¨×© Chrome 94+ ××• Edge 94+');
                return;
            }

            const list = document.getElementById('videoList');

            Array.from(files)
                .filter(f => f.type.startsWith('video/'))
                .forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'video-item';
                    item.innerHTML = `
                        <video src="${URL.createObjectURL(file)}" muted></video>
                        <div class="info">
                            <div class="name">${file.name}</div>
                            <div class="status">×‘×ª×•×¨...</div>
                        </div>
                        <button class="download">×”×•×¨×“ MP4</button>
                    `;
                    list.appendChild(item);
                    queue.push({ file, itemEl: item });
                });

            processQueue();
        }

        // ============== EVENTS ==============
        const dropZone = document.getElementById('dropZone');

        dropZone.onclick = () => document.getElementById('fileInput').click();
        dropZone.ondragover = e => { e.preventDefault(); dropZone.classList.add('dragover'); };
        dropZone.ondragleave = () => dropZone.classList.remove('dragover');
        dropZone.ondrop = e => { e.preventDefault(); dropZone.classList.remove('dragover'); addVideos(e.dataTransfer.files); };

        document.getElementById('fileInput').onchange = e => { addVideos(e.target.files); e.target.value = ''; };
        document.getElementById('folderInput').onchange = e => { addVideos(e.target.files); e.target.value = ''; };
    </script>
</body>
</html>
