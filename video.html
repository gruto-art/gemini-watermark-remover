<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ¬</text></svg>">
    <title>Veo Watermark Remover</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400&display=swap');

        * { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --primary: #8b5cf6;
            --primary-dark: #7c3aed;
            --accent: #06b6d4;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --dark: #0f0f1a;
            --dark-light: #1a1a2e;
            --gray: #6b7280;
            --gray-light: #9ca3af;
            --light: #f3f4f6;
            --white: #ffffff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--dark) 0%, #1a1a2e 100%);
            min-height: 100vh;
            color: var(--light);
        }

        .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #fff, #a5b4fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle { text-align: center; color: var(--gray-light); margin-bottom: 32px; }

        .card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .card h3 { color: var(--accent); margin-bottom: 12px; font-size: 1.1em; }
        .card p { color: var(--gray-light); line-height: 1.7; font-size: 0.95em; }
        .card code { background: rgba(139,92,246,0.2); padding: 2px 8px; border-radius: 4px; color: #c4b5fd; }

        .browser-support {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            margin-top: 16px;
            font-size: 0.9em;
        }

        .browser-support strong { color: var(--success); }

        .drop-zone {
            border: 2px dashed rgba(139,92,246,0.3);
            border-radius: 16px;
            padding: 50px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 24px;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(139,92,246,0.05);
        }

        .drop-zone h2 { font-size: 1.3em; margin-bottom: 8px; }
        .drop-zone p { color: var(--gray); }

        .btn-row { display: flex; gap: 12px; justify-content: center; margin-bottom: 24px; flex-wrap: wrap; }

        .btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 12px 24px;
            border-radius: 10px;
            color: var(--light);
            cursor: pointer;
            font-family: inherit;
            font-size: 0.95em;
            transition: all 0.2s;
        }

        .btn:hover { background: rgba(139,92,246,0.15); border-color: var(--primary); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        input[type="file"] { display: none; }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .setting label { display: block; color: var(--gray); font-size: 0.85em; margin-bottom: 6px; }
        .setting input[type="range"] { width: 100%; accent-color: var(--primary); }
        .setting .value { color: var(--primary); font-weight: 600; }

        .progress-section { display: none; }
        .progress-section.active { display: block; }

        .progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 12px 0;
        }

        .progress-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.2s;
        }

        .progress-info { display: flex; justify-content: space-between; font-size: 0.85em; color: var(--gray); }

        .video-list { display: flex; flex-direction: column; gap: 12px; }

        .video-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .video-item video {
            width: 100px; height: 56px;
            object-fit: cover;
            border-radius: 6px;
            background: #000;
        }

        .video-item .info { flex: 1; }
        .video-item .name { font-weight: 500; margin-bottom: 4px; font-size: 0.95em; }
        .video-item .status { font-size: 0.85em; color: var(--gray); }
        .video-item .status.processing { color: var(--warning); }
        .video-item .status.done { color: var(--success); }
        .video-item .status.error { color: var(--error); }

        .video-item .download {
            background: var(--success);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            display: none;
        }

        .video-item.done .download { display: block; }

        .back-link { color: var(--gray); text-decoration: none; display: inline-block; margin-bottom: 20px; }
        .back-link:hover { color: var(--light); }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">â† ×—×–×¨×” ×œ×ª××•× ×•×ª</a>

        <h1>Veo Watermark Remover</h1>
        <p class="subtitle">×”×¡×¨×ª ×¡×™××Ÿ ×”××™× "Veo" ××¡×¨×˜×•× ×™ Google Veo</p>

        <div class="card">
            <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
            <p>
                ×¡×¨×˜×•× ×™ Veo ××’×™×¢×™× ×¢× ×˜×§×¡×˜ <code>Veo</code> ×©×§×•×£ ×‘×¤×™× ×” ×”×™×× ×™×ª ×”×ª×—×ª×•× ×”.
                ×”×›×œ×™ ××©×ª××© ×‘-<strong>Reverse Alpha Blending</strong> - × ×•×¡×—×” ××ª××˜×™×ª ×©××©×—×–×¨×ª ××ª ×”×¤×™×§×¡×œ×™× ×”××§×•×¨×™×™×:
            </p>
            <p style="margin-top: 8px; font-family: monospace; color: var(--accent);">
                Original = (Current - White Ã— Î±) / (1 - Î±)
            </p>
            <div class="browser-support">
                <strong>×ª××™×›×”:</strong> Chrome 94+, Edge 94+, Opera 80+ (WebCodecs API)<br>
                ×¤×œ×˜: WebM (VP9) ×‘××™×›×•×ª ×’×‘×•×”×”
            </div>
        </div>

        <div class="drop-zone" id="dropZone">
            <h2>×’×¨×•×¨ ×¡×¨×˜×•× ×™× ×œ×›××Ÿ</h2>
            <p>××• ×œ×—×¥ ×œ×‘×—×™×¨×ª ×§×‘×¦×™× â€¢ MP4, WebM, MOV</p>
        </div>

        <div class="btn-row">
            <label class="btn">
                ×‘×—×¨ ×¡×¨×˜×•×Ÿ
                <input type="file" id="fileInput" accept="video/*">
            </label>
            <label class="btn">
                ×‘×—×¨ ×ª×™×§×™×™×”
                <input type="file" id="folderInput" webkitdirectory multiple accept="video/*">
            </label>
        </div>

        <div class="card">
            <h3>×”×’×“×¨×•×ª (××›×•×™×œ×•×ª ×œ×¤×™ ××“×™×“×”)</h3>
            <div class="settings-grid">
                <div class="setting">
                    <label>×©×§×™×¤×•×ª: <span class="value" id="opacityVal">0.52</span></label>
                    <input type="range" id="opacity" min="0.3" max="0.7" step="0.02" value="0.52">
                </div>
                <div class="setting">
                    <label>×’×•×“×œ ×’×•×¤×Ÿ: <span class="value" id="fontSizeVal">26</span>px</label>
                    <input type="range" id="fontSize" min="18" max="40" step="1" value="26">
                </div>
                <div class="setting">
                    <label>××¨×•×•×— ××™××™×Ÿ: <span class="value" id="marginRightVal">20</span>px</label>
                    <input type="range" id="marginRight" min="5" max="60" step="1" value="20">
                </div>
                <div class="setting">
                    <label>××¨×•×•×— ××œ××˜×”: <span class="value" id="marginBottomVal">12</span>px</label>
                    <input type="range" id="marginBottom" min="5" max="60" step="1" value="12">
                </div>
            </div>
            <p style="margin-top: 12px; font-size: 0.8em; color: var(--gray);">
                ×˜×™×¤: ×× × ×©××¨ ×¦×œ - ×”×’×“×œ ×©×§×™×¤×•×ª. ×× × ×•×¦×¨ ×›×ª× ×›×”×” - ×”×§×˜×Ÿ.
            </p>
        </div>

        <div class="card progress-section" id="progressSection">
            <div class="progress-info">
                <span id="progressText">××¢×‘×“...</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="fill" id="progressFill"></div>
            </div>
            <div class="progress-info">
                <span id="currentFile">-</span>
                <span id="eta">-</span>
            </div>
        </div>

        <div class="video-list" id="videoList"></div>
    </div>

    <script>
        // ============== CONFIG ==============
        const CONFIG = {
            text: 'Veo',
            fontFamily: 'Poppins, Google Sans, Arial, sans-serif',
            fontSize: 26,
            opacity: 0.52,
            marginRight: 20,
            marginBottom: 12,
            fontWeight: '400'
        };

        // Settings UI
        ['opacity', 'fontSize', 'marginRight', 'marginBottom'].forEach(key => {
            const input = document.getElementById(key);
            const display = document.getElementById(key + 'Val');
            input.addEventListener('input', () => {
                CONFIG[key] = parseFloat(input.value);
                display.textContent = key === 'opacity' ? CONFIG[key].toFixed(2) : CONFIG[key];
            });
        });

        // ============== WATERMARK MASK ==============
        function createMask(videoWidth, videoHeight) {
            const scale = Math.min(videoWidth, videoHeight) / 1080;
            const fontSize = Math.round(CONFIG.fontSize * scale);
            const marginRight = Math.round(CONFIG.marginRight * scale);
            const marginBottom = Math.round(CONFIG.marginBottom * scale);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            ctx.font = `${CONFIG.fontWeight} ${fontSize}px ${CONFIG.fontFamily}`;
            const metrics = ctx.measureText(CONFIG.text);
            const w = Math.ceil(metrics.width) + 12;
            const h = Math.ceil(fontSize * 1.3);

            canvas.width = w;
            canvas.height = h;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, w, h);
            ctx.font = `${CONFIG.fontWeight} ${fontSize}px ${CONFIG.fontFamily}`;
            ctx.fillStyle = 'white';
            ctx.textBaseline = 'middle';
            ctx.fillText(CONFIG.text, 6, h / 2);

            const imgData = ctx.getImageData(0, 0, w, h);
            const mask = new Float32Array(w * h);

            for (let i = 0; i < mask.length; i++) {
                const brightness = Math.max(imgData.data[i*4], imgData.data[i*4+1], imgData.data[i*4+2]);
                mask[i] = (brightness / 255) * CONFIG.opacity;
            }

            return {
                mask, w, h,
                x: videoWidth - w - marginRight,
                y: videoHeight - h - marginBottom
            };
        }

        function removeWatermark(imageData, mask) {
            const d = imageData.data;
            const imgW = imageData.width;

            for (let y = 0; y < mask.h; y++) {
                for (let x = 0; x < mask.w; x++) {
                    const imgX = mask.x + x;
                    const imgY = mask.y + y;
                    if (imgX < 0 || imgX >= imgW || imgY < 0 || imgY >= imageData.height) continue;

                    const idx = (imgY * imgW + imgX) * 4;
                    const alpha = mask.mask[y * mask.w + x];
                    if (alpha < 0.01) continue;

                    const a = Math.min(alpha, 0.98);
                    const div = 1 - a;

                    d[idx]   = Math.max(0, Math.min(255, Math.round((d[idx]   - a * 255) / div)));
                    d[idx+1] = Math.max(0, Math.min(255, Math.round((d[idx+1] - a * 255) / div)));
                    d[idx+2] = Math.max(0, Math.min(255, Math.round((d[idx+2] - a * 255) / div)));
                }
            }
        }

        // ============== VIDEO PROCESSING ==============
        const queue = [];
        let processing = false;

        function updateProgress(pct, text, file, eta) {
            document.getElementById('progressFill').style.width = pct + '%';
            document.getElementById('progressPercent').textContent = Math.round(pct) + '%';
            if (text) document.getElementById('progressText').textContent = text;
            if (file) document.getElementById('currentFile').textContent = file;
            if (eta !== undefined) document.getElementById('eta').textContent = eta;
        }

        async function processVideo(file, itemEl) {
            const statusEl = itemEl.querySelector('.status');

            // Check WebCodecs support
            if (typeof VideoEncoder === 'undefined') {
                throw new Error('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘-WebCodecs. × ×¡×” Chrome/Edge');
            }

            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;

            await new Promise((res, rej) => { video.onloadedmetadata = res; video.onerror = rej; });

            const W = video.videoWidth;
            const H = video.videoHeight;
            const duration = video.duration;
            const fps = 30;
            const totalFrames = Math.ceil(duration * fps);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = W;
            canvas.height = H;

            const mask = createMask(W, H);
            const startTime = Date.now();

            statusEl.textContent = '××›×™×Ÿ ×§×™×“×•×“...';

            // Use WebCodecs VideoEncoder
            const encodedChunks = [];

            const encoder = new VideoEncoder({
                output: (chunk, meta) => {
                    const buf = new ArrayBuffer(chunk.byteLength);
                    chunk.copyTo(buf);
                    encodedChunks.push({ data: buf, timestamp: chunk.timestamp, type: chunk.type, duration: chunk.duration });
                },
                error: (e) => console.error('Encoder error:', e)
            });

            encoder.configure({
                codec: 'vp09.00.10.08',
                width: W,
                height: H,
                bitrate: 5_000_000,
                framerate: fps
            });

            statusEl.textContent = `××¢×‘×“ ${totalFrames} ×¤×¨×™×™××™×...`;

            // Process frames
            for (let i = 0; i < totalFrames; i++) {
                video.currentTime = i / fps;
                await new Promise(r => video.onseeked = r);

                ctx.drawImage(video, 0, 0);
                const imgData = ctx.getImageData(0, 0, W, H);
                removeWatermark(imgData, mask);
                ctx.putImageData(imgData, 0, 0);

                const frame = new VideoFrame(canvas, {
                    timestamp: (i / fps) * 1_000_000,
                    duration: (1 / fps) * 1_000_000
                });

                encoder.encode(frame, { keyFrame: i % 60 === 0 });
                frame.close();

                const pct = (i / totalFrames) * 90;
                const elapsed = (Date.now() - startTime) / 1000;
                const rate = (i + 1) / elapsed;
                const remaining = Math.round((totalFrames - i - 1) / rate);

                updateProgress(pct, `×¤×¨×™×™× ${i + 1}/${totalFrames}`, file.name, `× ×•×ª×¨: ${remaining}s`);

                // Allow UI updates
                if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
            }

            await encoder.flush();
            encoder.close();

            updateProgress(95, '×™×•×¦×¨ ×§×•×‘×¥ WebM...', file.name, '');
            statusEl.textContent = '×™×•×¦×¨ ×§×•×‘×¥ WebM...';

            // Create WebM file manually
            const webmBlob = createWebM(encodedChunks, W, H, fps, duration);

            URL.revokeObjectURL(video.src);
            return webmBlob;
        }

        // Simple WebM muxer
        function createWebM(chunks, width, height, fps, duration) {
            // Use a simpler approach - just encode as raw VP9 in WebM container
            // This is a minimal WebM header + VP9 data

            const EBML_HEADER = new Uint8Array([
                0x1A, 0x45, 0xDF, 0xA3, // EBML
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, // Size
                0x42, 0x86, 0x81, 0x01, // EBMLVersion
                0x42, 0xF7, 0x81, 0x01, // EBMLReadVersion
                0x42, 0xF2, 0x81, 0x04, // EBMLMaxIDLength
                0x42, 0xF3, 0x81, 0x08, // EBMLMaxSizeLength
                0x42, 0x82, 0x84, 0x77, 0x65, 0x62, 0x6D, // DocType "webm"
                0x42, 0x87, 0x81, 0x04, // DocTypeVersion
                0x42, 0x85, 0x81, 0x02  // DocTypeReadVersion
            ]);

            // For simplicity, let's use MediaRecorder as fallback since WebM muxing is complex
            // Actually, let's just return the raw data and use a different approach

            // Concatenate all chunk data
            const totalSize = chunks.reduce((sum, c) => sum + c.data.byteLength, 0);
            const combined = new Uint8Array(totalSize);
            let offset = 0;
            for (const chunk of chunks) {
                combined.set(new Uint8Array(chunk.data), offset);
                offset += chunk.data.byteLength;
            }

            // Return as blob - this won't be a valid WebM but shows the approach
            return new Blob([combined], { type: 'video/webm' });
        }

        // Alternative: Use MediaRecorder for proper WebM output
        async function processVideoWithMediaRecorder(file, itemEl) {
            const statusEl = itemEl.querySelector('.status');

            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;

            await new Promise((res, rej) => { video.onloadedmetadata = res; video.onerror = rej; });

            const W = video.videoWidth;
            const H = video.videoHeight;
            const duration = video.duration;
            const fps = 30;
            const totalFrames = Math.ceil(duration * fps);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = W;
            canvas.height = H;

            const mask = createMask(W, H);
            const startTime = Date.now();

            statusEl.textContent = `××¢×‘×“ ${totalFrames} ×¤×¨×™×™××™×...`;

            // First pass: process all frames
            const processedFrames = [];
            for (let i = 0; i < totalFrames; i++) {
                video.currentTime = i / fps;
                await new Promise(r => video.onseeked = r);

                ctx.drawImage(video, 0, 0);
                const imgData = ctx.getImageData(0, 0, W, H);
                removeWatermark(imgData, mask);
                ctx.putImageData(imgData, 0, 0);

                processedFrames.push(await createImageBitmap(canvas));

                const pct = (i / totalFrames) * 50;
                const elapsed = (Date.now() - startTime) / 1000;
                const rate = (i + 1) / elapsed;
                const remaining = Math.round((totalFrames - i - 1) / rate);

                updateProgress(pct, `×¤×¨×™×™× ${i + 1}/${totalFrames}`, file.name, `× ×•×ª×¨: ${remaining}s`);

                if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
            }

            statusEl.textContent = '××§×•×“×“ ×•×™×“××•...';
            updateProgress(50, '××§×•×“×“ ×•×™×“××•...', file.name, '');

            // Second pass: encode with MediaRecorder at correct speed
            const stream = canvas.captureStream(fps);
            const recorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 5_000_000
            });

            const chunks = [];
            recorder.ondataavailable = e => { if (e.data.size) chunks.push(e.data); };

            const recordingDone = new Promise(resolve => {
                recorder.onstop = () => resolve(new Blob(chunks, { type: 'video/webm' }));
            });

            recorder.start();

            // Play frames at exact timing
            const frameTime = 1000 / fps;
            for (let i = 0; i < processedFrames.length; i++) {
                const frameStart = performance.now();
                ctx.drawImage(processedFrames[i], 0, 0);

                const pct = 50 + (i / processedFrames.length) * 50;
                updateProgress(pct, '××§×•×“×“...', file.name, '');

                // Wait for exact frame timing
                const elapsed = performance.now() - frameStart;
                if (elapsed < frameTime) {
                    await new Promise(r => setTimeout(r, frameTime - elapsed));
                }
            }

            recorder.stop();
            const blob = await recordingDone;

            // Cleanup
            processedFrames.forEach(f => f.close());
            URL.revokeObjectURL(video.src);

            return blob;
        }

        async function processQueue() {
            if (processing || queue.length === 0) return;
            processing = true;

            document.getElementById('progressSection').classList.add('active');

            while (queue.length > 0) {
                const { file, itemEl } = queue.shift();
                const statusEl = itemEl.querySelector('.status');
                statusEl.className = 'status processing';

                try {
                    // Use MediaRecorder approach (more compatible)
                    const blob = await processVideoWithMediaRecorder(file, itemEl);

                    const url = URL.createObjectURL(blob);
                    const dlBtn = itemEl.querySelector('.download');
                    dlBtn.onclick = () => {
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = file.name.replace(/\.[^.]+$/, '') + '-clean.webm';
                        a.click();
                    };

                    dlBtn.click(); // Auto download

                    statusEl.textContent = '×”×•×©×œ×! (' + (blob.size / 1024 / 1024).toFixed(1) + ' MB)';
                    statusEl.className = 'status done';
                    itemEl.classList.add('done');

                } catch (err) {
                    console.error(err);
                    statusEl.textContent = '×©×’×™××”: ' + err.message;
                    statusEl.className = 'status error';
                }
            }

            processing = false;
            document.getElementById('progressSection').classList.remove('active');
        }

        function addVideos(files) {
            const list = document.getElementById('videoList');

            Array.from(files)
                .filter(f => f.type.startsWith('video/'))
                .forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'video-item';
                    item.innerHTML = `
                        <video src="${URL.createObjectURL(file)}" muted></video>
                        <div class="info">
                            <div class="name">${file.name}</div>
                            <div class="status">×‘×ª×•×¨...</div>
                        </div>
                        <button class="download">×”×•×¨×“ WebM</button>
                    `;
                    list.appendChild(item);
                    queue.push({ file, itemEl: item });
                });

            processQueue();
        }

        // ============== EVENTS ==============
        const dropZone = document.getElementById('dropZone');

        dropZone.onclick = () => document.getElementById('fileInput').click();
        dropZone.ondragover = e => { e.preventDefault(); dropZone.classList.add('dragover'); };
        dropZone.ondragleave = () => dropZone.classList.remove('dragover');
        dropZone.ondrop = e => { e.preventDefault(); dropZone.classList.remove('dragover'); addVideos(e.dataTransfer.files); };

        document.getElementById('fileInput').onchange = e => { addVideos(e.target.files); e.target.value = ''; };
        document.getElementById('folderInput').onchange = e => { addVideos(e.target.files); e.target.value = ''; };
    </script>
</body>
</html>
